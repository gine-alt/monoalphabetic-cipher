<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Monoalphabetic Cipher Tool</title>
    
    <style>
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        
        .container {
            width: 90%;
            max-width: 900px;
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .info {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        
        .controls, .io-section {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #ecf0f1;
            border-radius: 8px;
            background-color: #fafafa;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #2980b9;
        }
        
        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 1.1em;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus, textarea:focus {
            border-color: #3498db;
            outline: none;
        }

        /* Invalid Key Styling */
        #keyInput.invalid-key {
            border: 2px solid #e74c3c;
            box-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
        }

        /* --- Key Map Styling --- */
        .key-map-container {
            overflow-x: auto;
            max-height: 200px;
            margin-top: 10px;
        }

        .key-map-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Ensures all 26 columns are equally sized */
            font-family: monospace;
            font-size: 0.8em;
            user-select: none;
            min-width: 600px; /* Prevent table from getting too narrow */
        }

        .key-map-table th, .key-map-table td {
            border: 1px solid #ccc;
            padding: 4px 2px;
            text-align: center;
            line-height: 1;
        }

        .key-map-table thead th {
            background-color: #f0f0f0; /* Plaintext row */
            font-weight: bold;
            color: #333;
        }

        .key-map-table tbody td {
            background-color: #ecf0f1; /* Ciphertext row */
            color: #2980b9;
            font-weight: bold;
        }

        .key-map-table tbody td.invalid-map-char {
            color: #e74c3c !important; /* Red question marks */
            background-color: #fcebeb;
        }
        
        .io-section {
            display: flex;
            flex-direction: column;
        }

        .text-area-group {
            flex: 1;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
            font-weight: bold;
        }
        
        #encryptBtn {
            background-color: #2ecc71;
            color: white;
        }
        
        #encryptBtn:hover:not(:disabled) {
            background-color: #27ae60;
        }
        
        #decryptBtn {
            background-color: #3498db;
            color: white;
        }
        
        #decryptBtn:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        textarea#outputText {
            background-color: #ecf0f1;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Monoalphabetic Cipher Tool</h1>
        <p class="info" style="text-align: center;">Encrypt or Decrypt using a custom 26-letter substitution key.</p>
        
        <div class="controls">
            <label for="keyInput">Cipher Key (26 unique letters A-Z):</label>
            <input type="text" id="keyInput" placeholder="Enter your 26-letter key here (e.g., QWERTYUIOPASDFGHJKLZXCVBNM)" maxlength="26" required pattern="[A-Za-z]{26}">
            <p class="info">Ensure the key contains all 26 letters of the alphabet exactly once.</p>

            <h2>Current Substitution Map</h2>
            <div class="key-map-container">
                <table class="key-map-table" id="keyMapTable">
                    <thead>
                        <tr>
                            </tr>
                    </thead>
                    <tbody>
                        <tr>
                            </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="io-section">
            <div class="text-area-group">
                <label for="inputText">Input Text (Plaintext or Ciphertext):</label>
                <textarea id="inputText" placeholder="Enter the message to process..."></textarea>
            </div>

            <div class="buttons">
                <button id="encryptBtn" disabled>Encrypt ðŸ”’</button>
                <button id="decryptBtn" disabled>Decrypt ðŸ”“</button>
            </div>

            <div class="text-area-group">
                <label for="outputText">Output Text:</label>
                <textarea id="outputText" readonly placeholder="Result will appear here..."></textarea>
            </div>
        </div>
    </div>

    <script>
        const STANDARD_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        
        const keyInput = document.getElementById('keyInput');
        const inputText = document.getElementById('inputText');
        const outputText = document.getElementById('outputText');
        const encryptBtn = document.getElementById('encryptBtn');
        const decryptBtn = document.getElementById('decryptBtn');
        const keyMapTable = document.getElementById('keyMapTable');
        
        // Default Key and Input Text for demonstration
        keyInput.value = "QWERTYUIOPASDFGHJKLZXCVBNM"; 
        inputText.value = "Monoalphabetic Cipher is fun!";


        /**
         * Validates the key and generates the substitution map.
         * Returns null if the key is invalid.
         */
        function createCipherMap(key, isEncryption) {
            const cleanKey = key.toUpperCase();
            
            // Check length
            if (cleanKey.length !== 26) return null;

            // Check for uniqueness and valid characters
            const uniqueChars = new Set(cleanKey.split('').filter(c => /[A-Z]/.test(c)));
            // Note: If the user inputs punctuation, .split() will include it, but .filter() will not. 
            // We check the size of the filtered set to ensure all 26 spots are filled by unique letters.
            if (uniqueChars.size !== 26) return null;

            const map = new Map();
            for (let i = 0; i < 26; i++) {
                const standardChar = STANDARD_ALPHABET[i];
                const keyChar = cleanKey[i];
                
                if (isEncryption) {
                    // Encryption: Standard char maps to Key char
                    map.set(standardChar, keyChar);
                } else {
                    // Decryption: Key char maps back to Standard char
                    map.set(keyChar, standardChar);
                }
            }
            return map;
        }

        /**
         * Performs the substitution (encryption or decryption), preserving case and non-alpha characters.
         */
        function substitute(text, map) {
            let output = [];
            for (const char of text) {
                if (/[A-Za-z]/.test(char)) {
                    const upperChar = char.toUpperCase();
                    const substitutedChar = map.get(upperChar);

                    if (substitutedChar) {
                        // Preserve case: if original char was uppercase, use uppercase substitution, else lowercase.
                        output.push(char === upperChar ? substitutedChar : substitutedChar.toLowerCase());
                    } else {
                        // Should only happen with an invalid key, but we fall back to preserving the character.
                        output.push(char);
                    }
                } else {
                    // Non-alphabetic characters (spaces, punctuation, numbers) are preserved
                    output.push(char);
                }
            }
            return output.join('');
        }
        
        /**
         * Updates the visual substitution table based on the current key's validity.
         */
        function updateKeyMapDisplay() {
            const key = keyInput.value.toUpperCase();
            const map = createCipherMap(key, true); // Always use the encryption map for display

            // Find header/body rows. Ensure they exist.
            let headerRow = keyMapTable.querySelector('thead tr');
            let bodyRow = keyMapTable.querySelector('tbody tr');

            if (!headerRow) {
                keyMapTable.querySelector('thead').innerHTML = '<tr></tr>';
                headerRow = keyMapTable.querySelector('thead tr');
            }
            if (!bodyRow) {
                keyMapTable.querySelector('tbody').innerHTML = '<tr></tr>';
                bodyRow = keyMapTable.querySelector('tbody tr');
            }
            
            headerRow.innerHTML = '';
            bodyRow.innerHTML = '';
            
            const isValid = !!map;

            // Populate the table
            for (let i = 0; i < 26; i++) { 
                const standardChar = STANDARD_ALPHABET[i];
                const keyChar = isValid ? map.get(standardChar) : '?';
                const charClass = isValid ? '' : 'invalid-map-char'; // For CSS styling

                // Row 1: Plaintext Alphabet (A, B, C...)
                headerRow.innerHTML += <th>${standardChar}</th>;
                
                // Row 2: Ciphertext Substitution (Q, W, E...)
                bodyRow.innerHTML += <td class="${charClass}">${keyChar}</td>;
            }
            
            // Highlight key input if invalid and disable buttons
            keyInput.classList.toggle('invalid-key', !isValid);
            encryptBtn.disabled = !isValid;
            decryptBtn.disabled = !isValid;
        }

        /**
         * Handler for the Encrypt button.
         */
        function handleEncrypt() {
            const map = createCipherMap(keyInput.value, true); 
            if (map) {
                outputText.value = substitute(inputText.value, map);
            }
        }

        /**
         * Handler for the Decrypt button.
         */
        function handleDecrypt() {
            const map = createCipherMap(keyInput.value, false); 
            if (map) {
                outputText.value = substitute(inputText.value, map);
            }
        }

        // --- Event Listeners and Initial Setup ---

        // 1. Update map display whenever the key changes
        keyInput.addEventListener('input', updateKeyMapDisplay);
        
        // 2. Add button click handlers
        encryptBtn.addEventListener('click', handleEncrypt);
        decryptBtn.addEventListener('click', handleDecrypt);

        // 3. Initial setup (must be called once at the start)
        window.addEventListener('load', updateKeyMapDisplay);
        // Also call immediately for initial content
        updateKeyMapDisplay();

    </script>
</body>
</html>
